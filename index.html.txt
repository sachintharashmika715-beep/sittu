 I'll provide a production-ready architecture for your Seettu (ROSCA) application. Given the financial nature and real-time requirements, I'll recommend **React Native + Firebase (Firestore)** for live circle updates, but I'll include SQL alternatives where architecture differs significantly.

## 1. System Architecture Overview

```
┌─────────────────┐      ┌──────────────────┐      ┌─────────────────┐
│   React Native  │      │   Node.js API    │      │   Firestore DB  │
│   (Expo/Bare)   │◄────►│   (Express)      │◄────►│   (Primary)     │
│                 │      │                  │      │                 │
│ • Biometric Auth│      │ • Transaction    │      │ • Real-time     │
│ • Offline Cache │      │   Logic          │      │   Sync          │
│ • Secure Store  │      │ • KYC Processing │      │ • Atomic Ops    │
└─────────────────┘      └──────────────────┘      └─────────────────┘
         │                        │                          │
         └────────────────────────┴──────────────────────────┘
                                  │
                    ┌─────────────▼──────────────┐
                    │   Firebase Cloud Storage   │
                    │   (KYC Documents)          │
                    └────────────────────────────┘
```

## 2. Database Schema Design

### Option A: Firestore (NoSQL) - Recommended for Real-time

**Collection: `users`**
```javascript
{
  userId: string,           // Firebase Auth UID
  phone: string,            // +94771234567
  email: string,
  pinHash: string,          // bcrypt encrypted
  biometricEnabled: boolean,
  
  // Profile
  fullName: string,
  dateOfBirth: timestamp,
  avatarUrl: string,
  
  // KYC Status
  verificationStatus: {
    idStatus: 'pending' | 'verified' | 'rejected',  // Blocker for joining
    addressStatus: 'pending' | 'verified' | 'rejected',
    rejectionReason: string,
    verifiedAt: timestamp,
    verifiedBy: string        // Admin ID
  },
  
  // Documents (References)
  kycDocuments: {
    idFront: string,         // Cloud Storage URL
    idBack: string,
    idNumber: string,        // NIC/Passport (encrypted)
    addressDoc: string,      // Utility bill URL
    uploadedAt: timestamp
  },
  
  // Wallet
  wallet: {
    balance: number,         // cents/smallest unit
    currency: 'LKR',
    escrowLocked: number     // Amount in active circles
  },
  
  metadata: {
    createdAt: timestamp,
    lastLogin: timestamp,
    deviceTokens: string[]   // FCM for notifications
  }
}
```

**Collection: `circles` (The Seettu)**
```javascript
{
  circleId: string,
  name: string,              // "Family Savings Jan 2026"
  description: string,
  
  // Configuration
  contributionAmount: number,    // Monthly contribution (e.g., 10000 LKR)
  totalRounds: 10,               // Fixed for your requirement
  frequency: 'monthly',          // or 'weekly'
  startDate: timestamp,
  
  // Participants (CRITICAL SECTION)
  participants: [
    {
      userId: string,
      slotNumber: number,        // 1-10 (immutable once assigned)
      status: 'active' | 'paid' | 'withdrawn',
      assignedAt: timestamp,
      receivedPayout: boolean,
      payoutRound: number        // Which round they got the pot
    }
  ],
  
  // State Management
  status: 'forming' | 'active' | 'completed' | 'cancelled',
  currentRound: number,          // 1-10
  availableSlots: number[],      // [3,5,7,9] - remaining
  
  // Financial tracking
  totalPool: number,
  nextPaymentDue: timestamp,
  
  // Security
  createdBy: string,             // User ID
  inviteCode: string,            // Hashed for private circles
  
  // Timestamps
  createdAt: timestamp,
  activatedAt: timestamp         // When 10th member joined
}
```

**Collection: `transactions`**
```javascript
{
  transactionId: string,
  type: 'contribution' | 'payout' | 'penalty' | 'refund',
  circleId: string,
  userId: string,
  amount: number,
  currency: 'LKR',
  status: 'pending' | 'completed' | 'failed',
  
  // Payment method integration
  paymentMethod: 'bank_transfer' | 'card' | 'wallet',
  externalRef: string,           // Bank transaction ID
  
  metadata: {
    roundNumber: number,
    slotNumber: number,
    description: string
  },
  
  timestamp: timestamp,
  processedBy: string            // System or Admin ID
}
```

**Collection: `audit_logs`** (For compliance)
```javascript
{
  action: 'slot_assigned' | 'kyc_approved' | 'payment_made',
  userId: string,
  circleId: string,
  ipAddress: string,
  deviceInfo: string,
  timestamp: timestamp,
  changes: object                 // Diff of what changed
}
```

### Option B: PostgreSQL Schema (SQL Alternative)

```sql
-- Users table
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    phone VARCHAR(20) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE,
    pin_hash VARCHAR(255),
    biometric_enabled BOOLEAN DEFAULT false,
    full_name VARCHAR(255),
    
    -- KYC Fields
    id_status VARCHAR(20) DEFAULT 'pending' CHECK (id_status IN ('pending', 'verified', 'rejected')),
    address_status VARCHAR(20) DEFAULT 'pending',
    id_number VARCHAR(50) ENCRYPTED,  -- Use pgcrypto
    verified_at TIMESTAMP,
    
    wallet_balance DECIMAL(12,2) DEFAULT 0.00,
    created_at TIMESTAMP DEFAULT NOW(),
    
    CONSTRAINT chk_id_verified CHECK (
        (id_status = 'verified') OR (circle_participants.user_id IS NULL)
    )
);

-- Circles table
CREATE TABLE circles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    contribution_amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) DEFAULT 'forming',
    current_round INTEGER DEFAULT 0,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    activated_at TIMESTAMP
);

-- Critical junction table with unique constraint
CREATE TABLE circle_participants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    circle_id UUID REFERENCES circles(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id),
    slot_number INTEGER NOT NULL CHECK (slot_number BETWEEN 1 AND 10),
    joined_at TIMESTAMP DEFAULT NOW(),
    payout_round INTEGER,
    
    UNIQUE(circle_id, slot_number),  -- CRITICAL: Prevents duplicate slots
    UNIQUE(circle_id, user_id),      -- Prevents double joining
    CONSTRAINT chk_user_verified CHECK (
        EXISTS (SELECT 1 FROM users WHERE users.id = user_id AND users.id_status = 'verified')
    )
);

-- Create index for fast slot availability checking
CREATE INDEX idx_circle_slots ON circle_participants(circle_id, slot_number);
```

## 3. Core Logic: Atomic Slot Assignment

This is the most critical piece. **Race conditions here would break the entire system.**

### Firestore Implementation (Transaction-based)

```typescript
// services/circleService.ts
import { 
  firestore, 
  FieldValue, 
  runTransaction 
} from '../config/firebase';

export class CircleService {
  
  /**
   * Atomically assigns a slot (1-10) to a user
   * Returns the assigned slot number or throws error
   */
  async joinCircle(circleId: string, userId: string): Promise<number> {
    const circleRef = firestore.collection('circles').doc(circleId);
    const userRef = firestore.collection('users').doc(userId);
    
    return runTransaction(async (transaction) => {
      // 1. Read phase: Get fresh data
      const circleDoc = await transaction.get(circleRef);
      const userDoc = await transaction.get(userRef);
      
      if (!circleDoc.exists) throw new Error('Circle not found');
      if (!userDoc.exists) throw new Error('User not found');
      
      const circleData = circleDoc.data();
      const userData = userDoc.data();
      
      // 2. Validation checks
      if (userData.verificationStatus?.idStatus !== 'verified') {
        throw new Error('ID verification required');
      }
      
      if (circleData.status !== 'forming') {
        throw new Error('Circle is no longer accepting members');
      }
      
      // Check if user already joined
      const existingParticipant = circleData.participants?.find(
        (p: any) => p.userId === userId
      );
      if (existingParticipant) {
        throw new Error('User already in circle');
      }
      
      // 3. Slot assignment logic
      const participants = circleData.participants || [];
      if (participants.length >= 10) {
        throw new Error('Circle is full');
      }
      
      // Find lowest available slot (1-10)
      const usedSlots = new Set(participants.map((p: any) => p.slotNumber));
      let assignedSlot = 1;
      while (assignedSlot <= 10 && usedSlots.has(assignedSlot)) {
        assignedSlot++;
      }
      
      if (assignedSlot > 10) {
        throw new Error('No slots available');
      }
      
      // 4. Write phase: Atomic update
      const newParticipant = {
        userId,
        slotNumber: assignedSlot,
        joinedAt: FieldValue.serverTimestamp(),
        status: 'active',
        receivedPayout: false
      };
      
      const isLastSlot = participants.length === 9;
      
      transaction.update(circleRef, {
        participants: FieldValue.arrayUnion(newParticipant),
        availableSlots: FieldValue.arrayRemove(assignedSlot),
        status: isLastSlot ? 'active' : 'forming',
        activatedAt: isLastSlot ? FieldValue.serverTimestamp() : null,
        updatedAt: FieldValue.serverTimestamp()
      });
      
      // 5. Audit log (async, don't block transaction)
      this.logAudit({
        action: 'slot_assigned',
        userId,
        circleId,
        metadata: { slotNumber: assignedSlot }
      });
      
      return assignedSlot;
    });
  }
  
  // Alternative: Let user choose specific available slot
  async joinCircleWithChoice(
    circleId: string, 
    userId: string, 
    preferredSlot: number
  ): Promise<number> {
    // Validate preferredSlot is 1-10 and available within transaction
    // Same pattern as above, but check if preferredSlot is in availableSlots array
  }
}
```

### SQL Implementation (SELECT FOR UPDATE)

```typescript
// services/circleServiceSQL.ts
import { Pool } from 'pg';

export class CircleServiceSQL {
  constructor(private db: Pool) {}
  
  async joinCircle(circleId: string, userId: string): Promise<number> {
    const client = await this.db.connect();
    
    try {
      await client.query('BEGIN');
      
      // Lock the circle row to prevent concurrent modifications
      const circleLock = await client.query(
        `SELECT status, 
                (SELECT COUNT(*) FROM circle_participants WHERE circle_id = $1) as participant_count
         FROM circles 
         WHERE id = $1 
         FOR UPDATE`,
        [circleId]
      );
      
      if (circleLock.rows[0].status !== 'forming') {
        throw new Error('Circle not forming');
      }
      
      if (parseInt(circleLock.rows[0].participant_count) >= 10) {
        throw new Error('Circle full');
      }
      
      // Verify user KYC
      const userCheck = await client.query(
        `SELECT id_status FROM users WHERE id = $1`,
        [userId]
      );
      
      if (userCheck.rows[0]?.id_status !== 'verified') {
        throw new Error('KYC not verified');
      }
      
      // Find lowest available slot using EXCEPT
      const slotQuery = await client.query(
        `SELECT slot_number 
         FROM generate_series(1, 10) AS slot_number
         WHERE slot_number NOT IN (
           SELECT slot_number FROM circle_participants WHERE circle_id = $1
         )
         ORDER BY slot_number 
         LIMIT 1`,
        [circleId]
      );
      
      if (slotQuery.rows.length === 0) {
        throw new Error('No slots available');
      }
      
      const assignedSlot = slotQuery.rows[0].slot_number;
      
      // Insert participant
      await client.query(
        `INSERT INTO circle_participants (circle_id, user_id, slot_number)
         VALUES ($1, $2, $3)`,
        [circleId, userId, assignedSlot]
      );
      
      // Update circle status if full
      await client.query(
        `UPDATE circles 
         SET status = CASE 
           WHEN (SELECT COUNT(*) FROM circle_participants WHERE circle_id = $1) = 10 
           THEN 'active' 
           ELSE status 
         END,
         activated_at = CASE 
           WHEN (SELECT COUNT(*) FROM circle_participants WHERE circle_id = $1) = 10 
           THEN NOW() 
           ELSE NULL 
         END
         WHERE id = $1`,
        [circleId]
      );
      
      await client.query('COMMIT');
      return assignedSlot;
      
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }
}
```

## 4. API Endpoints Specification

### Authentication Routes (`/api/auth`)

```typescript
// POST /api/auth/otp/send
// Request: { phone: "+94771234567" }
// Response: { sessionId: "xxx", expiresIn: 300 }
// Logic: Generate OTP, store in Redis with 5min TTL, send via SMS

// POST /api/auth/otp/verify
// Request: { sessionId: "xxx", otp: "123456" }
// Response: { tempToken: "jwt", isNewUser: boolean }

// POST /api/auth/register
// Headers: Authorization: Bearer {tempToken}
// Request: { 
//   email: "user@example.com", 
//   fullName: "John Doe",
//   pin: "1234"  // Will be hashed
// }
// Response: { userId: "uid", accessToken: "jwt", refreshToken: "jwt" }

// POST /api/auth/login
// Request: { phone: "+94771234567", pin: "1234" } OR { biometricToken: "xxx" }
// Response: { userId: "uid", accessToken: "jwt", requiresBiometric: boolean }

// POST /api/auth/biometric/register
// Headers: Authorization: Bearer {accessToken}
// Request: { publicKey: "xxx" }
// Logic: Store public key for challenge-response auth
```

### KYC Routes (`/api/kyc`)

```typescript
// POST /api/kyc/id-upload
// Headers: Authorization: Bearer {token}
// Content-Type: multipart/form-data
// Body: { 
//   idFront: File, 
//   idBack: File, 
//   idNumber: "123456789V",
//   idType: "nic" | "passport" 
// }
// Logic: 
//   1. Upload to Firebase Storage (encrypted at rest)
//   2. Update user.verificationStatus.idStatus = 'pending'
//   3. Trigger admin notification
//   4. Return document URLs

// POST /api/kyc/address-upload
// Similar to above, updates addressStatus

// GET /api/kyc/status
// Response: { 
//   id: { status: "verified", verifiedAt: "ISO" },
//   address: { status: "pending", reason: null }
// }
```

### Circle Management (`/api/circles`)

```typescript
// POST /api/circles
// Request: {
//   name: "Family Seettu",
//   contributionAmount: 10000,
//   frequency: "monthly",
//   startDate: "2026-03-01"
// }
// Response: { circleId: "xxx", inviteCode: "ABC123" }
// Logic: Creator is auto-assigned slot #1 (founder privilege) or joins as admin only

// POST /api/circles/:id/join
// Request: { preferredSlot?: 5 } // Optional
// Response: { assignedSlot: 5, position: 3, status: "forming" }
// Logic: Uses atomic transaction above, checks KYC status first

// GET /api/circles/:id
// Response: {
//   id: "xxx",
//   name: "Family Seettu",
//   status: "forming",
//   participants: [
//     { userId: "u1", slotNumber: 1, name: "Alice", avatar: "url" },
//     { userId: "u2", slotNumber: 2, name: "Bob", avatar: "url" }
//   ],
//   availableSlots: [3,4,5,6,7,8,9,10],
//   mySlot: null,  // If viewer hasn't joined
//   nextPayment: null
// }

// GET /api/circles/:id/slots
// Real-time endpoint (WebSocket/Firestore listener)
// Returns current slot occupancy for live UI updates
```

### User Dashboard (`/api/user`)

```typescript
// GET /api/user/dashboard
// Response: {
//   profile: { name, email, verificationStatus },
//   wallet: { balance: 50000, currency: "LKR" },
//   activeCircles: [
//     { 
//       circleId: "xxx", 
//       name: "Family Seettu", 
//       mySlot: 3, 
//       nextPaymentDue: "2026-03-01",
//       status: "active",
//       currentRound: 2
//     }
//   ],
//   pendingActions: [
//     { type: "kyc_required", message: "Upload ID to join circles" },
//     { type: "payment_due", circleId: "xxx", amount: 10000 }
//   ]
// }

// GET /api/user/transactions
// Query: ?page=1&limit=20&type=contribution|payout
// Response: Paginated list with circle names and amounts
```

## 5. React Native Architecture

### Project Structure
```
/src
  /api          # Axios instances & interceptors
  /components   # Reusable UI (SlotGrid, CircleCard, KYCUploader)
  /screens
    /Auth       # Login, OTP, PIN Setup, BiometricSetup
    /KYC        # IDUpload, AddressUpload, VerificationPending
    /Dashboard  # Home, Wallet, Transactions
    /Circles    # CreateCircle, JoinCircle, CircleDetail, SlotSelection
  /hooks        # useAuth, useCircle, useWallet (React Query)
  /context      # AuthContext, ThemeContext
  /services     # BiometricAuth, SecureStorage, ImagePicker
  /utils        # Validation, Formatters
  /config       # Firebase, API endpoints
```

### Critical Implementation Details

**Biometric + PIN Security Flow:**
```typescript
// services/authService.ts
import * as LocalAuthentication from 'expo-local-authentication';
import * as SecureStore from 'expo-secure-store';

export class AuthService {
  async setupPin(pin: string): Promise<void> {
    const hash = await bcrypt.hash(pin, 10);
    await SecureStore.setItemAsync('user_pin', hash);
  }
  
  async authenticateWithBiometric(): Promise<boolean> {
    const result = await LocalAuthentication.authenticateAsync({
      promptMessage: 'Authenticate to access Seettu',
      fallbackLabel: 'Use PIN',
      disableDeviceFallback: false
    });
    return result.success;
  }
  
  async authenticateWithPin(pin: string): Promise<boolean> {
    const storedHash = await SecureStore.getItemAsync('user_pin');
    return bcrypt.compare(pin, storedHash);
  }
}
```

**Real-time Circle Updates:**
```typescript
// hooks/useCircle.ts
import { useEffect, useState } from 'react';
import firestore from '@react-native-firebase/firestore';

export const useCircle = (circleId: string) => {
  const [circle, setCircle] = useState(null);
  
  useEffect(() => {
    // Real-time listener for slot changes
    const unsubscribe = firestore()
      .collection('circles')
      .doc(circleId)
      .onSnapshot(doc => {
        if (doc.exists) {
          setCircle({ id: doc.id, ...doc.data() });
        }
      });
      
    return () => unsubscribe();
  }, [circleId]);
  
  return circle;
};
```

**Image Handling for KYC:**
```typescript
// components/KYC/ImageUploader.tsx
import * as ImagePicker from 'expo-image-picker';
import { manipulateAsync, SaveFormat } from 'expo-image-manipulator';

const pickAndCompressImage = async () => {
  const result = await ImagePicker.launchImageLibraryAsync({
    mediaTypes: ImagePicker.MediaTypeOptions.Images,
    allowsEditing: true,
    aspect: [4, 3],
    quality: 0.8,
  });
  
  if (!result.canceled) {
    // Compress to reduce storage/bandwidth
    const manipulated = await manipulateAsync(
      result.assets[0].uri,
      [{ resize: { width: 1200 } }],
      { compress: 0.7, format: SaveFormat.JPEG }
    );
    return manipulated.uri;
  }
};
```

## 6. Security & Compliance Checklist

1. **Data Encryption:**
   - KYC documents: Encrypt in Firebase Storage with CSEK (Customer-Supplied Encryption Keys)
   - ID numbers: Encrypt in database (Firestore field encryption or SQL column encryption)
   - PINs: Never store plain text, use bcrypt/Argon2

2. **Rate Limiting (Express.js):**
   ```typescript
   import rateLimit from 'express-rate-limit';
   
   const otpLimiter = rateLimit({
     windowMs: 15 * 60 * 1000, // 15 minutes
     max: 3, // 3 attempts per window
     message: 'Too many OTP requests'
   });
   
   app.use('/api/auth/otp/', otpLimiter);
   ```

3. **Firestore Security Rules:**
   ```javascript
   match /circles/{circleId} {
     allow read: if request.auth != null;
     allow create: if request.auth != null 
       && request.resource.data.createdBy == request.auth.uid;
     allow update: if request.auth != null 
       && (
         // Only allow joining (appending to participants array)
         (request.resource.data.participants.size() > resource.data.participants.size()
          && request.resource.data.participants.hasAll(resource.data.participants))
         ||
         // Or admin operations
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin'
       );
   }
   ```

4. **Input Validation:** Use Joi or Zod for all API inputs to prevent injection attacks.

5. **Audit Trail:** Every financial transaction and KYC approval must be logged immutably.

This architecture ensures **atomic slot assignment** (no double-booking), **strict KYC gating**, and **real-time updates** essential for a ROSCA application. The separation of concerns between "forming" and "active" states prevents mid-transaction join attempts once the circle starts rotating.